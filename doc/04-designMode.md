#设计模式
##设计模式原则
> 面向接口编程  
> 职责单一原则  
> 对修改关闭，对扩展开放
## 设计模式分类
  设计模式的分类主要分为三类，创建型模式，结构性模式，行为型模式
### 创建型模式
  创建型模式的作用就是创建对象，创建对象，最常见的就是new一个对象，然后set设置相关属性,但是实际需要创建对象的场景很多
  
> 简单工厂  
  
通过一个public static 方法，根据输入返回不同的产品类实例  
> 工厂模式  
  
工厂模式跟简单工厂模式比就是比简单工厂多了一个选择工厂选择过程，一个工厂接口，几个工厂类，具体使用工厂类生产不同的物品
> 抽象工厂  

抽象工厂，当涉及到产品族的时候，就需要引入抽象工厂模式了，抽象工厂接口定义几个制造方法，每一类实现类分别实现这几个制造方法，分别对应产品族的各个部件，
缺点是如果需要添加新的方法，需要每一个工厂实现类都制造方法，违法对修改关闭，对扩展开放原则？ 怎么违反呢，不知道？？？？
> 单例模式

单例模式用的最多，错的最多
* 饿汉模式：最简单，主旨思想是设置private无参构造函数，然后设置私有静态变量，通过pulic getInstance方法返回实例，
缺点就是静态变量在类首次被使用到的时候就会生成，比如类里有其他静态方法被使用也会导致静态变量创建，耗费内存。
* 饱汉模式：最容易出错，主旨思想是设置private无参构造函数，然后设置私有静态volatile变量，不先实例化，通过getInstance判空即synchronized加锁进行实例化，
实例化时候也要先判空，原因是并发时候，a线程判空之后可能有b线程已经完成了实例并释放了锁，此时a线程如果获取到锁后不再次判空会导致重复实例。
* 嵌套类：最经典，在内部私有静态类里面建立私有静态外部类实例，客户端通过访问外部类公有静态getInstance方法返回嵌套类的实例。
* 枚举类：在类加载的时候会初始化里面的所有实例，而且jvm保证了他们不会再被实例化，所以它天生就是单例的。
> 建造者模式

Builder类，通常都是建造者模式的产物，客户端调用就是一个Builder然后链式地调用一堆方法，最后build()方法。
> 原型模式
 
原型模式，有一个原型实例，基于这个原型实例产生新的实例，也就是克隆了，Object类有clone()方法，需要使用clone()方法需要实现Cloneable接口
否则会抛出异常，这种克隆是浅克隆，也就是实例中对象引用，克隆结果跟原实例引用只想同一个对象，通常实现深克隆的方法是将对象序列化，然后反序列。
> 创建型模式总结

创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是需要创建一个对象了。
简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，
如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，
一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。
--------
### 结构型模式  
结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展
> 代理模式

代理模式是最常用的模式之一，用一个代理来隐藏具体实现类的实现细节，代理，就是要对客户端隐藏真实实现，
由代理来负责客户端的所有请求。代理模式说白了就是方法包装或者说方法增强，在面向切面编程中，其实就是动态
代理的过程。
> 适配器模式

适配器模式就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配，总体分为三类，默认，对象，类适配三类。
* Default Adapter 默认适配器  
当需要实现的接口方法很多，大多数用不到，可以定义一个中间类，将所有的方法实现为空方法，具体上线类继承适配类，可以只用重写自己需要的方法。
* 对象适配器  
无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的
适配器中定义一个鸡的实例，调用鸭接口的方法时，实际是通过调用鸡对应的方法重写了。属于组合方式
* 类适配器  
通过实现类的同名方法覆盖接口中的待实现方法，属于继承的方式
> 代理适配器模式总结

比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，
都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，
为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。
> 桥梁模式 

理解桥梁模式，其实就是理解代码抽象和解耦。  
主旨思想就是定义一个基础接口方法，然后定义几个基础实现类，同时定义一个使用者抽象类，抽象类里以接口作为一个属性值并定义有参构造函数，定义抽象接口同名方法，
使用基础实现类作为抽象类的构造参数，组合实现具体的实现类。
> 装饰器模式

要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 Java IO 中的几个类是典型的装饰模式的应用，
但是读者不一定清楚其中的关系。
主旨思想：先定义抽象基类，基础类继承实现抽象基类，装饰抽象类继承抽象基类，然后装饰实现类实现装饰抽象类，装饰实现类里定义一个私有基础接口属性，通过组合的方式进行装饰组合。
从名字来简单解释下装饰器。既然说是装饰，那么往往就是添加小功能这种，而且，我们要满足可以添加多个小功能。
最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，
但是那样的话代码就复杂了。  
？？？ **感觉桥梁和装饰器有些相似**
> 门面模式

门面模式也叫外观模式，Facade pattern,在许多源码中有使用，比如slf4j就可以理解为是门面模式的应用。
主旨思想：组合同一接口的不同实现类，然后做一个统一的实现类供调用。
> 组合模式

组合模式用于表示具有层级结构的数据，使得我们对单个对象和组合对象的访问具有一致性。
> 享元模式

英文是Flyweight pattern，共享元器件，复用已经生成的对象，复用对象最简单的方式就是用一个hashmap存放每次新生成的对象，每次需要
一个对象的时候，先到hashmap中看看有没有，如果没有，再生成新的对象，然后将这个对象放入到hashmap中
>结构型模式总结

 代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，
 装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，
 门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，
 组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能
 
 --------------
 
 ### 行为型模式
 行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加清晰
 > 策略模式

主旨思想:跟桥梁模式很像，只是桥梁模式会定义一个使用者抽象类，多了一层抽象，更加松耦合。
> 观察者模式

观察者订阅自己关心的主题，主题有数据变化后通知观察者们
首先需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者
实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，
笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。
还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，
然后在事件发生的时候，遍历观察者，调用它们的回调函数。

> 责任链模式

责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，
只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。

> 模板方法模式

在含有继承机构的代码中，模板方法模式是非常常用的
主旨思想：定义一个抽象类，里面实现好模板方法，模板方法调用抽象方法，抽象方法具体由子类实现
> 状态模式----没太看明白

商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。
核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。
> 行为型模式总结

行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，
但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。
---------
### 总结
学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。